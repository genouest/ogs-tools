from Bio import Alphabet

from Bio.SeqIO.InsdcIO import EmblWriter
from Bio.SeqIO.InsdcIO import _insdc_location_string_ignoring_strand_and_subfeatures

"""
This version of the EMBL writer will write a valid EMBL file.
It is not ready for submission to EBI as they require a specific variation of it, that can be generated by BipaaEmblSubmitWriter
"""


def _insdc_location_string(location, rec_length):
    """Build a GenBank/EMBL location from a (Compound) FeatureLocation (PRIVATE).

    There is a choice of how to show joins on the reverse complement strand,
    GenBank used "complement(join(1,10),(20,100))" while EMBL used to use
    "join(complement(20,100),complement(1,10))" instead (but appears to have
    now adopted the GenBank convention). Notice that the order of the entries
    is reversed! This function therefore uses the first form. In this situation
    we expect the CompoundFeatureLocation and its parts to all be marked as
    strand == -1, and to be in the order 19:100 then 0:10.
    """
    try:
        parts = location.parts
        # CompoundFeatureLocation
        if location.strand == -1:
            # Special case, put complement outside the join/order/... and reverse order
            return "%s(%s)" % (location.operator,
                               ",".join(_insdc_location_string(p, rec_length)
                                        for p in parts[::-1]))
        else:
            return "%s(%s)" % (location.operator,
                               ",".join(_insdc_location_string(p, rec_length) for p in parts))
    except AttributeError:
        # Simple FeatureLocation
        loc = _insdc_location_string_ignoring_strand_and_subfeatures(location, rec_length)
        if location.strand == -1:
            return "complement(%s)" % loc
        else:
            return loc


class BipaaEmblWriter(EmblWriter):
    def _write_feature(self, feature, record_length):
        """Write a single SeqFeature object to features table."""
        assert feature.type, feature
        location = _insdc_location_string(feature.location, record_length)
        f_type = feature.type.replace(" ", "_")
        line = (self.QUALIFIER_INDENT_TMP % f_type)[:self.QUALIFIER_INDENT] + self._wrap_location(location) + "\n"
        self.handle.write(line)
        # Now the qualifiers...
        for key in sorted(feature.qualifiers.keys()):
            values = feature.qualifiers[key]
            if isinstance(values, list) or isinstance(values, tuple):
                for value in values:
                    self._write_feature_qualifier(key, value)
            else:
                # String, int, etc - or None for a /pseudo tpy entry
                self._write_feature_qualifier(key, values)

    def _write_the_first_lines(self, record):
        """Write the ID and AC lines."""
        if "." in record.id and record.id.rsplit(".", 1)[1].isdigit():
            version = "SV " + record.id.rsplit(".", 1)[1]
            accession = self._get_annotation_str(record, "accession",
                                                 record.id.rsplit(".", 1)[0],
                                                 just_first=True)
        else:
            version = ""
            accession = self._get_annotation_str(record, "accession",
                                                 record.id,
                                                 just_first=True)

        if ";" in accession:
            raise ValueError("Cannot have semi-colon in EMBL accession, %s"
                             % repr(str(accession)))
        if " " in accession:
            # This is out of practicallity... might it be allowed?
            raise ValueError("Cannot have spaces in EMBL accession, %s"
                             % repr(str(accession)))

        # Get the molecule type
        # TODO - record this explicitly in the parser?
        # Get the base alphabet (underneath any Gapped or StopCodon encoding)
        a = Alphabet._get_base_alphabet(record.seq.alphabet)
        if not isinstance(a, Alphabet.Alphabet):
            raise TypeError("Invalid alphabet")
        elif isinstance(a, Alphabet.DNAAlphabet):
            mol_type = "genomic DNA"
            units = "BP"
        elif isinstance(a, Alphabet.RNAAlphabet):
            mol_type = "RNA"
            units = "BP"
        elif isinstance(a, Alphabet.ProteinAlphabet):
            mol_type = "PROTEIN"
            units = "AA"
        else:
            # Must be something like NucleotideAlphabet
            raise ValueError("Need a DNA, RNA or Protein alphabet")

        # Get the taxonomy division
        division = self._get_data_division(record)

        # TODO - Full ID line
        handle = self.handle
        # ID   <1>; SV <2>; <3>; <4>; <5>; <6>; <7> BP.
        # 1. Primary accession number
        # 2. Sequence version number
        # 3. Topology: 'circular' or 'linear'
        # 4. Molecule type
        # 5. Data class
        # 6. Taxonomic division
        # 7. Sequence length
        self._write_single_line("ID", "%s; %s; %s; %s; CON; %s; %i %s."
                                % (accession, version, 'linear', mol_type,
                                   division, len(record), units))
        handle.write("XX\n")
        self.handle.write("AC", accession + ";")
        handle.write("XX\n")
